import FormStepper from '../bundles/steppers/form_stepper';
import { setup_dependent_checkboxes } from '../bundles/utilities/helpers';

// Handles the property form validators (new, edit)
$(document).on('turbolinks:load', function(e) {
  window.ParsleyConfig = {
    errorsWrapper: '<li class="alert-box-item"></li>',
    errorTemplate: '<span></span>',
    excluded:
    // Defaults
      'input[type=button],' +
      'input[type=submit],' +
      'input[type=reset],'  +
      'input[type=hidden],' +
      '[disabled],'         +
      ':hidden,'            +
      // -- Additional attributes to look --
      '[data-parsley-disabled],' +  // Exclude specific input/select/radio/checkbox/etc
      '[data-parsley-disabled] *'   // Exclude all nesting inputs/selects/radios/checkboxes/etc
  };

  const $stepperForm = $('#new_property, [id^=edit_property_]');
  if ($stepperForm.length < 1) return;

  window.form_stepper = new FormStepper($stepperForm);

  // --------------------------------
  // Sets up the checkbox-dependant input fields in step 3 (amenities)

  // --------------------------------

  // --------------------------------
  /**
   * -=SOS=-
   * AS concept:
   *
   * AS works by XHRing files to the server first and getting back a unique upload key (string) for each one.
   * It then appends this upload key to autogenerated hidden form fields and submits these along with the rest form
   * fields on normal form submission.
   *
   * Multistep form workflow:
   *
   * When a multistep form with partial validations and attachments is submitted things may get a bit complicated:
   * 1. Parsley validator will always intercept the request "at the lowest possible level" (button click) and run
   * its validations. If the validation fails it will stop the form dead on its tracks. No further action happens.
   * 2. Each time a form is submitted 2 main form handler functions run: active storage for handling file uploads and
   * UJS for ajax form submission. Both listen to (mostly) the same events and use ajax calls for their own purposes.
   * 3. Once Parsley validations pass, the system keeps track of whether a user has used any attachments or not:
   *   a. If the user has placed files-to-be uploaded on uppyjs then UJS gets an event.preventDefault and stops. AS
   *      takes over and uploads all files. Once it's done, it removes #preventformsubmit from the DOM and resubmits the
   *      form. On form resubmission AS won't do anything this time since there will be no files left to upload leaving
   *      room for UJS to normally submit the form since #preventformsubmit will be missing.
   *   b. If the user doesn't have any files to upload, then the corresponding form field is removed and the form is
   *      normally submitted through UJS .
   */
  $stepperForm.on('ajax:before', function(event, xhr, opts) {
    // DEBUG
    // console.log('ajax:before event called');
    if ($('#preventformsubmit').length > 0) {
      // DEBUG
      // console.log('#preventformsubmit exists');
      if (Object.keys(window.uppy_uploader.getState().files).length) {
        // DEBUG
        // console.log('files are: ' + Object.keys(window.uppy_uploader.getState().files).length);
        event.preventDefault();
        return false;
      } else {
        // Remove element from DOM before ujs serializes the form
        $(event.target)
          .find('#property_images')
          .remove();
      }
    }
  });
  // --------------------------------

  // This handles the nested property owner form to either select from an existing list or create a new
  $('.client-radio-selection').on('click', (e) => {
    let selectedOption = $(e.target).attr('id');
    let counterElements = $(`#${selectedOption}`).data().counteroption.split(',');
    $(counterElements).each((index, counterElement) => $(`.${counterElement}`).addClass('disabledElement'));
    $(counterElements).each((index, counterElement) => $(`.${counterElement}`).find(`input.${counterElement}_input`).attr('disabled', true));
    $(`.${selectedOption}`).removeClass('disabledElement');
    $(`.${selectedOption}`).find(`input.${selectedOption}_input, textarea.${selectedOption}_input`).removeClass('disabledElement');
    $(`.${selectedOption}`).find(`input.${selectedOption}_input, textarea.${selectedOption}_input`).attr('disabled', false);
  });

  // We need the focus event to reset state in the animated/themed form input fields
  // ...and we also need to direct the user to the first input field
  $('.client-radio-selection.edit').one('click', (e) => {
    $('.new_client_input').val('');
    $('.new_client_input').focus();
    $('.new_client_input').first().focus();
  });

});


function leavePage(msg) {
  if (confirm(msg)) {
    if (("form_stepper" in window) && (window.form_stepper !== null)){
      window.form_stepper.kill();
      window.form_stepper = null;
    }
    return true;
  } else {
    return false;
  }
}

// This basically listens for window unload
$(document).on("page:before-change turbolinks:before-visit", function() {
  // Make sure it only works on the properties stepper
  if (window.location.pathname === '/app/properties/new' || window.location.pathname.match(/^\/app\/properties\/[a-zA-Z]{2}\d+\/edit$/)) {
    // Gets the stepper status. If untouched then don't bug the user. Otherwise, show a warning
    if (!window.form_stepper.getStatus()) return;
    var alertsDomNode = $('#alerts');
    var alertsTranslations = alertsDomNode.data('i18n').alerts;
    return leavePage(alertsTranslations['leave_page']);
  }
});


