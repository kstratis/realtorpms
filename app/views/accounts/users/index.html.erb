<% provide(:title, t('users.title')) %>

<!-- Notice the use of render partial -->
<%= render partial: 'layouts/breadcrumb', locals: {path: [{:title => t('users.index.breadcrumb'), :href => users_path}], icon: 'house-colored'} %>

<div class="page-container">
  <div class="container">
    <div class="app-container">

<!--      <div class="btn-group pull-right" role="group" aria-label="...">-->

          <%#= link_to new_invitation_path, :class => 'btn btn-primary btn-sm invite-user', :id => 'invite-user-button' do %>
          <%# end %>



          <%#= link_to new_invitation_path, :class => 'btn btn-primary btn-sm add-user', :id => 'add-user-button' do %>

          <%# end %>

<!--      </div>-->

      <%# Here we call render not on a string with the name of a partial, but rather on a user variable of class User;
          in this context, Rails automatically looks for a partial called _user.html.erb, which we must create.
          This is a definite improvement, but we can do even better: we can call render directly on the @users variable
          Here Rails infers that @users is a list of User objects; moreover, when called with a collection of users,
          Rails automatically iterates through them and renders each one with the _user.html.erb partial
          (inferring the name of the partial from the name of the class). %>
      <%#= render @users %>

      <!--<div class="clearfix"></div>-->
      <%#= will_paginate %>
<!--    </div>-->
<!--  </div>-->
<!--  <div class="row">-->
<!--    <div class="col-md-12">-->
      <!--<div class="col-md-6 col-md-offset-3">-->
        <%#= react_component('Search', prerender: false) %>
      <!--</div>-->

      <%# Here we call render not on a string with the name of a partial, but rather on a user variable of class User;
          in this context, Rails automatically looks for a partial called _user.html.erb, which we must create.
          This is a definite improvement, but we can do even better: we can call render directly on the @users variable
          Here Rails infers that @users is a list of User objects; moreover, when called with a collection of users,
          Rails automatically iterates through them and renders each one with the _user.html.erb partial
          (inferring the name of the partial from the name of the class). %>
      <%#= render @users %>
      <!--<div class="col-md-12">-->
        <%#= react_component('UsersList', props: @userslist, prerender: false) %>
        <%= react_component('UsersListWithDatatable', props: {
            initial_payload: {
                dataset_wrapper: @userslist,
                results_per_page: @results_per_page,
                total_entries: @total_entries,
                current_page: @current_page,
                initial_search: @initial_search,
                initial_sorting: @initial_sorting,
                initial_ordering: @initial_ordering,
                add_user_link: new_invitation_path,
                object_type: 'users'
            },
            i18n: {
                datatable: t('js.datatables.users'),
                result_count: t('js.datatables.pagination.results'),
                no_results: t('js.datatables.users.no_results'),
                search: t('js.users_search.placeholder'),
                add: t('invitations.new.heading')

            },
            meta: {
                freeze_link:  toggle_activation_user_url('USERID')
            }
          }, prerender: false) %>
      <!--</div>-->

      <div class="clearfix"></div>
      <%#= will_paginate %>
    </div>
  </div>
</div>